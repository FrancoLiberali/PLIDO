import struct
import binascii

###

type_name = ["CON", "NON", "ACK", "RST"]
CON = 0
NON = 1
ACK = 2
RST = 3

code_name = ["EMPTY", "GET", "POST", "PUT", "DELETE"]

EMPTY = 0
GET = 1
POST = 2
PUT = 3
DELETE = 4

####


default_mid = 1


class Message:

    """
    class CoAP for client and server
    """

    def __init__( self, buf = b'' ):
        self.buffer = buf
        self.option = 0

    def new_header ( self, type = CON, code = EMPTY, token = None, mid = None, midSize = 16 ):

        global default_mid

        if mid == None:
            mid = default_mid
            default_mid = ( default_mid + 1 ) % ( 1 << midSize )
            if ( default_mid == 0 ): default_mid = 1  # mid = 0 may be ack with a random number

        self.buffer = bytearray()

        tkl = 0
        if token:
            for i in range(0,8):
                if token & (0xFF << 8*i) != 0x00:
                    tkl = i+1

        assert (tkl < 8)

        # First 32 bit word
        byte = ( ( 0x01 ) << 6 ) | ( type << 4 ) | tkl  # need to compute token length

        self.buffer = struct.pack ( '!BBH', byte, code, mid)

        for i in range(0, tkl):
            v = (token & (0xFF << 8*(tkl-i-1)))
            v >>=(8*(tkl-i-1))

            self.buffer += struct.pack('B', v)
# In some cases the Message ID size must be limited to a smaller number of bits
# To allow rule selection, especially with MSB the size must be controlled


    def __add_option_TL ( self, T, L ):
        delta = T - self.option
        self.option = T

        if ( delta < 13 ) and ( L < 13 ) is True:
            self.buffer += struct.pack( 'B', ( delta << 4 ) | L )
        else:
            print( 'Not Done' )


    def add_option_path( self, path = '' ):
        self.__add_option_TL( 11, len( path ) )
        self.buffer += bytearray(path, encoding="utf-8")

    def add_option_query( self, query = '' ):
        self.__add_option_TL( 15, len( query ) )
        self.buffer += query

    def add_option_content (self, value):
        if (value < 0xFF):
            self.__add_option_TL( 12, 1)
            self.buffer += struct.pack( 'B', value )

    def end_option( self ):
        self.buffer += struct.pack( 'B', 0xFF )

    def add_value( self, m = '' ):
        if ( type( m ) ) == type( str() ):
            print ( "we have a string" )
            self.buffer == m
        elif ( type( m ) == CBOR ):
            for char in m.buffer:
                self.buffer += struct.pack( 'B', char )


    def to_byte( self ):
        return self.buffer


    def get_tkl(self):
        return self.buffer[0] & 0b00001111

    def get_type ( self ):
        return( ( self.buffer[0] & 0x30 ) >> 4 )

    def get_mid( self ):
        return self.buffer[2] << 8 | self.buffer[3]

    def get_code( self ):
        return self.buffer[1]

    def dump(self, hexa=False):
        if hexa:
            print (binascii.hexlify(self.buffer)

        code = self.get_code()
        clas = code >> 5
        detail = code & 0b00011111
        if clas == 0:
            c_name = code_name[code]
        else:
            c_name = '{0:x}.{1:02X}'.format(clas, detail)

        print ("{0:4} 0x{1:04X} {2:6s}".format(
            type_name[self.get_type()],
            self.get_mid(), c_name
            ), end="")

        buf_ptr = 4

        tkl = self.get_tkl()
        if tkl > 0:
            print ("T=", end="")
            for i in range (0, tkl):
                print ("{:02X}".format(self.buffer[buf_ptr]), end="")
                buf_ptr += 1
        print ()

if __name__ == "__main__":
    coap = Message()

    coap.new_header(token=0x1122334455)
    coap.dump()
